import { Pcg32 } from '@std/random/_pcg32.ts'
import type { ByteGenerator } from '@std/random/_types.ts'
import { nextFloat64 } from '@std/random/number_types.ts'
import { NumberTypeName, numberTypeNameMap, NumberTypeShortName, NumericTypeOf } from './numberTypes.ts'
import { CryptoPrng } from './crypto.ts'
import { unreachable } from '@std/assert/unreachable'
import { advance } from './advance.ts'

type WordSize = 1 | 2 | 4 | 8 | 16
type Prng = Pcg32 | CryptoPrng
export type SerializedPrng = `pcg32_${string}_${string}`

function getWordSizeForPrng(prng: Prng): WordSize {
	if (prng instanceof Pcg32) return 4
	if (prng instanceof CryptoPrng) return 1 // arbitrary size, we use 1 to avoid wasting generated bytes
	const _: never = prng
	unreachable()
}

export type Links = {
	prev: string
	self: string
	next: string
}

export type Output = {
	type: NumberTypeShortName
	values: number[] | `${bigint}`[]
	_links: Links | null
}

/** @throws {InvalidSeedError} */
export function getResults({ seed, type, count, searchParams = new URLSearchParams() }: {
	seed: string | null
	type: NumberTypeShortName
	count: number
	searchParams?: URLSearchParams
}): Output {
	searchParams = new URLSearchParams(searchParams)
	searchParams.set('type', type)
	searchParams.set('count', String(count))

	const prng = seedToPrng(seed)

	let numbers: (number | bigint)[]
	let _links: Links | null = null

	if (prng instanceof Pcg32) {
		const wordSize = getWordSizeForPrng(prng)
		const numWordsPerElement = getNumWordsPerElement(numberTypeNameMap.get(type), wordSize)

		const self = withSeedQueryParam(prng, searchParams)

		numbers = generateNumbers(prng, type, count)

		const next = withSeedQueryParam(prng, searchParams)
		const prev = withSeedQueryParam(advance.call(prng, -BigInt(count * numWordsPerElement * 2)), searchParams)

		_links = { prev, self, next }
	} else {
		numbers = generateNumbers(prng, type, count)
	}

	const values = typeof numbers[0] === 'bigint' ? numbers.map(String) as `${bigint}`[] : numbers as number[]

	return { type, values, _links }
}

function withSeedQueryParam(prng: Pcg32, searchParams: URLSearchParams): string {
	searchParams.set('seed', serialize(prng))
	return `?${searchParams.toString()}`
}

function serialize(prng: Pcg32): SerializedPrng {
	return `pcg32_${u64ToHex(prng.state)}_${u64ToHex(prng.increment)}`
}

function u64ToHex(value: bigint): string {
	return value.toString(16).padStart(16, '0')
}

export function generateNumbers<T extends NumberTypeShortName>(
	prng: Prng,
	type: T,
	count: number,
): NumericTypeOf<T>[] {
	const byteGenerator: ByteGenerator = prng.getRandomValues.bind(prng)
	if (type === 'f64') {
		return Array.from({ length: count }, () => nextFloat64(byteGenerator) as NumericTypeOf<T>)
	}

	const numberType = numberTypeNameMap.get(type)
	const wordSize = getWordSizeForPrng(prng)

	const numWordsPerElement = getNumWordsPerElement(numberType, wordSize) * wordSize
	const method = `get${numberType}` as const

	const b = byteGenerator(new Uint8Array(numWordsPerElement * count))
	const dv = new DataView(b.buffer)

	return Array.from({ length: count }, (_, i) => {
		const offset = i * numWordsPerElement
		return dv[method](offset, true) as NumericTypeOf<T>
	})
}

export function getNumWordsPerElement(type: NumberTypeName, wordSize: WordSize): number {
	return Math.ceil(globalThis[`${type}Array`].BYTES_PER_ELEMENT / wordSize)
}

export function isPositiveIntString(value: string) {
	return /^\d+$/.test(value)
}

export class InvalidSeedError extends Error {
	override name = this.constructor.name
}

/** @throws {InvalidSeedError} */
export function seedToPrng(seed: string | null): Prng {
	if (seed == null) return CryptoPrng.instance

	if (isPositiveIntString(seed)) {
		return new Pcg32(BigInt(seed))
	} else if (/^pcg32_[0-9a-f]{16}_[0-9a-f]{16}$/.test(seed)) {
		const [state, increment] = seed.split('_').slice(1).map((x) => BigInt(`0x${x}`))
		if ((increment & 1n) === 0n) {
			throw new InvalidSeedError(`Invalid increment: 0x${u64ToHex(increment)}. \`increment\` must be odd`)
		}
		return new Pcg32({ state, increment })
	} else {
		throw new InvalidSeedError(`Invalid seed: ${seed}`)
	}
}

export function randomSeed() {
	return crypto.getRandomValues(new BigUint64Array(1))[0]!
}
